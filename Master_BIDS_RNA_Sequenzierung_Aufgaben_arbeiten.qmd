---
about: ---
title: "RNA-Sequenzierungs-Analyse - Aufgaben"
author: "Constanze Leichtweiß (Gruppe 3)"
format:
  html:
    toc: true
    number-sections: true
    df-print: paged
    code-fold: false
    embed-resources: true
execute:
  cache: true
  echo: true
  warning: false
  error: false
editor: visual
---n
---

# Einführung

Wir bitten euch hier, die grundlegenden Schritte einer RNA-Sequenzierungs-Analyse durchzuführen. Wir stellen euch bereits die auf das menschliche Referenzgenom ausgerichteten Reads zur Verfügung, d.h. euer Ausgangspunkt sind die "Raw Counts" für alle Gene jeder Probe. Zusammen mit den Counts stellen wir euch die Annotationstabelle zur Verfügung, die die Proben-IDs mit den tatsächlichen biologischen Bedingungen verknüpft. Der Datensatz stammt aus einem wissenschaftlichen Projekt, an dem wir hier in Freiburg arbeiten. Der Datensatz enthält Expressionsdaten eines Rektumadenokarzinoms, welches Varianten in ***BRAF^D594G^***, ***KRAS^G12A^*** und ***TP53^R175H^*** trägt. Mit dem RNA-Seq-Experiment soll untersucht werden, welchen Einfluss die Medikamente **Sorafenib** und **Trametinib** auf das Expressionsmuster der Tumorzellen haben. Um die Vergleiche vornehme zu können wurde ebenfalls eine Kontrollprobe mit **Dimethylsulfoxid** (DMSO) generiert. DMSO wurde gewählt, da die Medikamente darin gelöst sind, um sie den Zellen zuverabreichen. Wir betrachten im folgenden also die biologischen Bedingungen **DMSO**, n

**Sorafenib** (Sora) und **Trametinib** (Tram). Für alle Bedingungen liegen zwei biologische Replikate vor.

Das Ziel dieser Aufgabe ist es die signifikant veränderten Gene zwischen der Kontrolle (DMSO) und den beiden Behandlungen (Sora und Tram) zu finden. Des weiteren interssiert uns auch, ob es Unterschiede zwischen den Behandlungen gibt. Dabei hilft uns in beiden Fällen die Analyse der differentiell exprimierten Gene (DEG).

Im folgenden beschreiben wir die Aufgaben und geben euch weitere Hinweise und Erklärungen.aa

Wir werden in den nächsten Wochen schrittweise folgende Punkte bearbeiten:

1.  Importieren der Count Daten und erstellen einer Count Matrix
2.  Verknüpfung der Daten zu tatsächlichen biologischen Bedingungen
3.  Erstellen einer Tabelle, die alle Gene und ihre zugehörigen Gen-Identifikatoren enthält.
4.  Berechnung einer Hauptkomponentenanalyse (PCA), um einen ersten Überblick über den Datensatz zu erhalten
5.  Die DEG-Analyse
6.  Vergleich zwischen den Medikamenten
7.  Gene-Set Enrichment Analyse (GSEA)
8.  Visualisieren und Exportieren der Ergebnisse

Daraus resultieren folgende Aufgaben/ Fragen für euch. Wir haben diese auf die drei verbleibenden Wochen aufgeteilt. Weitere Details findet ihr fortlaufend in diesem Dokument.

**Aufgaben/ Fragen Woche 4**

Vorbereitung:

1.  Importiert die Count-Daten und erstellt daraus eine Count-Matrix
2.  Erstellt eine Tabelle, die alle gemessenen Gene und all ihre verschiedenen IDs enthält.
3.  Ordnet den Proben ihre biologische Bedingung zu
4.  Erstellt das DESeq2 Objekt und normalisiert die Daten
5.  Erstellt zwei QC Abbildungen, einmal mit den Roh-Counts und einmal mit den normalisierten Count-Werten.

**Aufgaben/ Fragen Woche 5**

DEG-Analyse:

1.  Berechnet eine Principal Component Analysis (PCA) und stellt diese grafisch dar.
2.  Baut auf dem DESeq2 Objekt auf und führt die *"Differentially Expressed Genes"* (DEG) Analyse durch.
    i)  Bestimmt die DEGs für die beiden Vergleiche Sorafenib vs DMSO und Trametinib vs DMSO
    ii) Wie viele DEGs konntet ihr pro Vergleich identifizieren? (Cutoff padj \< 0.05)
    iii) Wie verteilen sich die Anzahl der DEGs auf hoch- bzw. runter-reguliert? (log2FoldChange \> bzw. \< 0)
    iv) Stellt die Anzahlen grafisch z.B. als Barplot dar.
3.  Baut die signifikanten DEGs als Übersichtstabellen ins HTML ein.
4.  Stellt die Ergebnisse der DEG-Analyse mit Hilfe eines *Volcano Plots* dar.

**Aufgabe/ Fragen Woche 6**

Vergleich der beiden Medikamente:

1.  Findet Gemeinsamkeiten und Unterschiede zwischen den beiden Medikamenten im Vergleich zu DMSO.
2.  Wendet einen Exakten Test nach Fischer an um aus den Genen veränderte Gensets/ Signalwege abzuleiten. Diese Art der Analyse nennt man *funktionelle Analyse* oder auch *"Gene-Set Enrichment Analysis (GSEA)"*.
3.  Stellt die Ergebnisse grafisch dar.

## R Pakete

Verwendete R Paket:

```{r}
#| collapse: false

# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install(version = "3.21")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("BiocParallel")


library(DESeq2)
library(openxlsx)
library(pheatmap)
library(org.Hs.eg.db)
library(ggplot2)
library(FactoMineR)
library(ggrepel)
library(apeglm)
library(ggrepel)
library(viridis)
library(tidyverse)
library(kableExtra)
library(pheatmap)
library(genefilter)
library(EnhancedVolcano)
library(UpSetR)
library(msigdbr)
#library(doMC) # falls es hiermit Probleme gibt könnt ihr das Paket auch weglassen
#library(foreach) # falls es hiermit Probleme gibt könnt ihr das Paket auch weglassen
#library(BiocParallel) # falls es hiermit Probleme gibt könnt ihr das Paket auch weglassen
# optional -> increase speed of analysis due to multicore processing
#register(MulticoreParam(4)) # -> diese Zeile löschen, wenn es Probleme mit den Paketen doMC, foreach und/ oder BiocParallel gab
```

n

Hinweis: Falls diese nicht installiert sind, können sie mit dem Paketmanager von [bioconductor](https://www.bioconductor.org/install/) `BiocManager::install()` oder `install.packages()` installiert werden.

```{r}
#| eval: false
packages <- c(
  "doMC",
  "foreach",
  "BiocParallel",
  "UpSetR",
  "genefilter",
  "DESeq2",
  "openxlsx",
  "pheatmap",
  "org.Hs.eg.db",
  "ggplot2",
  "FactoMineR",
  "ggrepel",
  "apeglm",
  "viridis",
  "tidyverse",
  "kableExtra",
  "pheatmap",
  "EnhancedVolcano",
  "msigdbr"
)
BiocManager::install(packages)
```

## Konfiguration

```{r}
#| warning: false
#| 
## general config
#getwd()
#C:/Users/LeichtweissC.GSINET/OneDrive - delaware/Desktop/medizinischeInformatik/MIRACUM_BIDS_Bioinformatik_Systembiologie_RNA_Sequenzierung_Aufgabe"
mainDir <-"C:/Users/LeichtweissC/Desktop/medizinischeInformatik/MIRACUM_BIDS_Bioinformatik_Systembiologie_RNA_Sequenzierung_Aufgabe"
analysisDir <- file.path(mainDir, "analysis")
degDIR <- file.path(analysisDir, "DEG")
gseaDIR <- file.path(analysisDir, "GSEA")
gageDIR <- file.path(analysisDir, "GSEA", "GAGE")
dir.create(degDIR, recursive = T)
dir.create(gageDIR, recursive = T)
```

**Setzen des Arbeitsverzeichnisses:** Die Funktion `setwd()` setz das Arbeitsverzeichnis und `getwd()` liest das aktuelle Arbeitsverzeichnis aus.

```{r}
setwd(mainDir)
getwd()
```

Bei nicht UNIX basierten Betriebssystemen, z.B. Microsoft Windows, müsst ihr aufpassen, da dort der Backslash als Trenner verwendet wird. Ihr könnte aber, wenn ihr nicht sicher sein, auch die Funktion `file.path(..., fsep = .Platform\$file.sep)` vewenden, z.B.

```{r}
#| warning: false
#| eval: false
file.path(
  "C:/Users/LeichtweissC/Desktop/medizinischeInformatik/MIRACUM_BIDS_Bioinformatik_Systembiologie_RNA_Sequenzierung_Aufgabe"
)
```

## Funktionen

Wir stellen euch ein paar Funktionen zur Verfügung, die euch bei der Konvertierung der verschiedenen Gen-IDs unterstützen können. Alle Konvertierungen sind in der Hauptfunktion `getGeneMat()` zusammengefasst. Diese nimmt als Input die ENSEMBL Gen-IDs und konvertiert diese in die anderen und fasst alles zu einem *"data.frame"* zusammen.

```{r}
ensembl2entrez <- function(ensembl) {
  entrez <- mget(as.character(ensembl), org.Hs.egENSEMBL2EG, ifnotfound = NA)
  entrez <- lapply(entrez, function(i) return(i[1]))
  return(unlist(entrez))
}

entrez2ensembl <- function(entrez) {
  esbl <- mget(as.character(entrez), org.Hs.egENSEMBL, ifnotfound = NA)
  esbl <- lapply(esbl, function(i) return(i[1]))
  return(unlist(esbl))
}

entrez2symbol <- function(entrez) {
  symbol <- mget(as.character(entrez), org.Hs.egSYMBOL, ifnotfound = NA)
  symbol <- unlist(lapply(symbol, function(i) return(i[1])))
  return(symbol)
}

entrez2genename <- function(entrez) {
  symbol <- mget(as.character(entrez), org.Hs.egGENENAME, ifnotfound = NA)
  symbol <- unlist(lapply(symbol, function(i) return(i[1])))
  return(symbol)
}

getGeneMat <- function(ensIDs) {
  geneMat <- data.frame(ENSEMBL=ensIDs)
  geneMat$ENTREZ <- ensembl2entrez(geneMat$ENSEMBL)
  idxNA <- !is.na(geneMat$ENTREZ)
  sym <- entrez2symbol(na.omit(geneMat$ENTREZ))
  genename <- entrez2genename(na.omit(geneMat$ENTREZ))
  geneMat$Symbol <- NA
  geneMat$Symbol[idxNA] <- sym
  geneMat$Genename <- NA
  geneMat$Genename[idxNA] <- genename
  rownames(geneMat) <- geneMat$ENSEMBL
  return(geneMat)
}
```

# Analyse

## Vorbereitung

### Importieren der Rohdaten aus dem Alignment und der Quantifizierung

Das ausrichten der Sequenzierungsschnipsel (Alignment der Reads) wurde mit dem Progamm **STAR** gemacht. STAR bietet außerdem die Möglichkeit auch gleich die Qunatifizierung der Expression vorzunemhen. Dabei wurde der Parameter `--quantMode GeneCount` verwendet. Hierzu wurde eine sogenannte GTF/ GFF Annotationsdatei benutzt, welche die Information beinhaltet, welches Gene zu welchen chromosomalen Koordinaten gehört. Wir betrachten hier ein *un-stranded*-RNA-Sequenzierungs Experiment.

Die einzelnen *.tab* Dateien beinhalten die Counts pro Gene. Dabei gibt die 1. Spalte den ENSEMBL Gen-Identifier an, z.B. *ENSG00000223972* und die 2. Spalte die entsprechenden un-stranded RNA-Seq Counts. Diese beiden Spalten brauchen wir im Folgenden. Die ersten vier Reihen geben ein paar Zusammenfassungsstatistiken über die Count Datei und werden nicht benötigt.

**Erstellt die Count Matrix und die Genreferenztabelle mit allen Genen und den zugehörigen IDs. Stellt die Count-Matrix, die betrachteten Gene und die Annotation der Proben zu den biologischen Bedingungen innerhalb des HTML Dokuments dar.**

```{r}
# Load /import count data
targets <- read.xlsx(xlsxFile = "targets.xlsx")
countFiles <- list.files(pattern = "ReadsPerGene.out.tab")
names(countFiles) <- gsub(
  pattern = "_ReadsPerGene.out.tab",
  replacement = "",
  countFiles
)
countList <- lapply(
  countFiles,
  read.delim,
  skip = 4,
  header = FALSE,
  stringsAsFactors = FALSE
)

targets$ID <- targets$label
targets$sample <- names(countFiles)
rownames(targets) <- targets$sample

# Create geneMat
ensIDs <- countList[[1]]$V1
geneMat <- getGeneMat(ensIDs)

# Make count table
countList <- lapply(
  countList,
  function(i) return(i[,2])
)
countMat <- do.call(
  cbind,
  countList
)
rownames(countMat) <- ensIDs

# Use IDs as labels
rownames(targets) <- targets$ID
colnames(countMat) <- targets$ID[match(colnames(countMat), targets$sample)]

write.table(
  x = countMat,
  file = file.path(analysisDir, "counts.txt"),
  sep = "\t",
  quote = FALSE
)
save(
  targets,
  geneMat,
  countMat,
  file = file.path(analysisDir, "countData.Rdata")
)

```

[Ziel der Arbeit:]{.underline}

Wir wollen untersuchen, ob die Gabe von Sora oder Tram eine statatisch sign. Veränderung der Genexpression hervorruft. Damit wir die Daten statistisch auswerten können, wollen wir uns zuerst ansehen, wie die vorliegenden Daten verteilt sind.

[Bemerkung zur Count Verteilung:]{.underline}

Grundsätzlich kann man zwei Verteilungen der RNA Zählwerten (RNA Zählwerte geben an, wieviel RNA Moleküle eines bestimmten Gens in einer Probe gefunden wurden) betrachten: Die Verteilung der RNA Zählwerte innerhalbe einer Probe und die Verteilung der Werte zwischen einzelnen Proben.

Die Verteilung zwischen den Proben kann sich je nach Zelltyp, Zustand, Behandlung etc. ändern. Dies kann man ausnutzen, um beispielsweise zu überprüfen , wie sich versch. Medikamente auf die Expression bestimmter Gene auswirken.

Ebenso variert die Anzahl exprimierter Gene Innerhalb der Probe. Es gibt sehr viele Gene , die eine geringe Anzahl der Counts aufweise, wohin gegen wenige Gene in hoher Zahl exprimiert sind. Dadurch erhalten wir eine rechtschiefe Verteilung, also keine Normalverteilung. Die Varianz in RNA Experimenten ist ebenfalls sehr groß. Dieses Phänomen ist auch als Overdispersion bekannt. Dieses Phänoment konnten wir an unserem Datensatz gut erkennen( siehe Zusatzinfo aus der Vorlesung)

Herkömmliche Verteilungen , wie Normal- oder Possion Verteilung, können daher nicht zur zur statistischen Berechnungen herangezogen werden. Vielmehr ist die negative Negative-Binomial-Verteilung dazu geeignet, um die Overdispersion zu modellieren.

DESeq2, ein statistisches Softwarepaket, verwendet eine solche negative Binomialverteilung, die speziell geeignet ist, um die Zählwerte von RNA-Seq-Daten (Count-Daten) zu modellieren.

Unterschiede in Sequenziertiefe und Library-Größe werden durch sogenannte Size Factors korrigiert. Dadurch sind die Proben vergleichbar. Ausserdem kann DESeq2 die Overdispersion schätzen, wodurch sich die Genauigkeit der p Werte verbessert, welche benötigt werden , um Vergleiche zwischen den einzelnen Medikamentengruppen anstellen zu können. Daher sehen wir uns nun an, wie wir ein DESeq erstellen können

[Erstellung DESeq2 Objekt]{.underline}

Um ein DESeq2-Objekt in R zu erstellen, benötigt man zwei Strukturen: die Zählmatrix selbst und eine Tabelle, die die Meta Daten über die zu testeten Proben enthält. Die Zeilen diese Meta Daten Tabelle beziehen sich auf dien einzelnen Proben, die Spalten beeinhalten die zu vergleichenden (Medikamenten) gruppen. Weil die Proben gerade die Spalten der Count Matrix sind, nennt man´die Metadatentabelle auch colData( col = colums).

Das Design `~ Condition` legt fest, dass DESeq2 Unterschiede zwischen den Gruppen analysieren soll. (faktorielles Design). Es gibt noch weitere Designs

`mcols(dds)` referenziert die Metadaten der Zeilen der Gen Matrix.

Vorbereiten des DESeq2 Objektes

Im nächsten Abschnitt wird das DESeq2-Modell erstellt. Damit wird die Grundlage für die spätere Analyse der differentiell exprimierten Gene (DEG) gelegt. Hierbei ist das Handbuch von [DESeq2](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html) sehr hilfreich. Wir importieren die Daten auf Grundlage der erstellten Count-Matrix, analog zu [Count-Matrix-Import](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#count-matrix-input). Nach dem Import und dem Erstellen des DESeq2 Objektes müssen wir die Rohdaten einem [Vorfilter](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#pre-filtering) Schritt unterziehen um sehr niedrige Counts zu entfernen. Hierbei is es hilfreich sich zu überlegen, wie viele biologische Replikate wir pro Bedingung haben. Idealerweise entfernt man alle Gene, die im vorliegenden Experiment in Summer über alle Bedingungen weniger als 5-10 Counts haben.

```{r}
# Define Comparisons, Design, etc.
targets$Condition <- factor(
  targets$group,
  levels = c(
    "DMSO",
    "Sorafenib",
    "Trametinib"
  )
)

# build DESeq2 model
dds <- DESeqDataSetFromMatrix(
  countData = countMat,
  colData = targets,
  design = ~ Condition
)

# add gene meta data
mcols(dds) <- DataFrame(mcols(dds), geneMat)

# filtering low expressed genes
print(paste0("Vor dem Filtern: ", dim(dds)[1], " Gene"))


```

**Wie viele Gene verlieren wir aufgrund von niedriger Expression?**

```{r}
keep <- rowSums(counts(dds) >= 10) >= 2 # 5 or 10 counts for at least 2 conditions (we have 2 replicates per condition and a gene should be present in both if it is biologically relevant)
dds <- dds[keep,]

print(paste0("Nach dem Filtern: ", dim(dds)[1], " Gene"))

```

### Normalisierung und Differentielle Expression

Nachdem wir die schwach exprimierten Gene entfernt haben können wir die Normalisierung der Daten vornehmen. Dazu müssen wir die *"size factors"* und die *"Dispersion"* bestimmen, damit wir den tatsächlichen Signifikanztest (wir wollen den Wald- Test verwenden) anwenden können. Außerdem müssen wir die normalisierten Expressionswerte extrahieren, damit wir damit z.B. eine PCA erstellen können. Dazu verwenden wir die [*regularized logarithm* (rlog) Transformation](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#regularized-log-transformation). Die Werte können dann mit der Funktion `assay()` extrahiert werden.

```{r Size Factors, Dispersion, Wald test}

# normalizing, and differential expression analysis
dds <- DESeq(
  object = dds,
  test = "Wald",
  fitType = "parametric",
  parallel = TRUE
)

dds.counts <- counts(
  dds,
  normalized=TRUE
)
#dds <- estimateSizeFactors(dds)
#dds <- estimateDispersions(dds)
#dds <- nbinomWaldTest(dds)

# get normalized rlogs
rld <- rlogTransformation(dds)
rlds <- assay(rld)

# get vst
vst_obj <- vst(dds)
```

```{r}
rlog_matrix <- assay(rld)
head(rlog_matrix) 

dds <- DESeq(dds)
res <- results(dds)
```

[Erläuterung:]{.underline}

DESeq2 steht für Differential Expression analysis using Sequencing data – Version 2

`dds` ist in DESeq2 ein Objekt vom Typ Typ `DESeqDataSet` , das alle Informationen enthält, die wir für die weitere Analyse benötigen: die Counts (Rohzähldaten), die Metadaten zu den Proben, das Design model und die Ergebnisse.

design = \~ condition bedeutet zum Beispiel, dass getestet wird, ob sich die Gene signifikant zwischen den Bedingungen unterscheiden

`assay` eine Matrix mit numerischen Messwerten, die zu einem `DESeqDataSet`-Objekt gehört. Der Aufruf assay() kann unterschiedlich Daten zurückgeben

assy(dds) gibt die Rohdaten, also die Counts zurück. assay(rlog(dds)) gibt gibt die log transformierten Werte zurück, assay(vst) die varianzstabilisierte Werte

Die size factors Werte sagen aus, wie stark jede Probe skaliert wird, um technische Unterschiede auszugleichen. Es gibt daher soviele Size Factors wie Proben. Nach der Skalierung kann man die normalisierten Werte extrahieren. Mit den normalisierten Werten kann man dann zum Beispiel eine PCA machen

Die Dispersion beschreibt, wie stark die Genexpression innerhalb einer Bedingung variiert **.** Ohne eine gute Schätzung der Dispersion wären die statistischen Tests ungenauso oder zu liberal, vor allem bei Genen, die eine niedrige Anzahl von Counts vorweisen, deren Varianz größer als der Mittewert ist. Das sorgt dann für verzerrte Ergebnisse zum Beispiel bei der PCA

Mit der gefunden Dispersion kann man die Verteilung der Counts angeben. Dies ist eine negative Biniomnial verteilung mit zwei Parametern, nämlich dem Mittelwert und der Varianz.

LFC steht für Log2 Fold Change — also der logarithmische (zur Basis 2) Unterschied in der Expression eines Gens zwischen zwei Bedingungen.

Shrinking (auch Shrinkage) in DESeq2 bedeutet, dass die geschätzten Log2 Fold Changes (LFCs) „verkleinert“ oder stabilisiert werden, besonders bei Genen mit niedrigem oder sehr variablen Signal.

Bei Genen mit **wenig Counts** oder **hoher Streuung** sind die LFC-Schätzungen oft **extrem und unsicher**. Ohne Shrinking können solche Werte übertrieben groß sein und zu **falsch interpretierten Ergebnissen** führen. Die unsicheren Werte werden in Richtung Null gezogen.

Dabei ist anzumerken, dass Gene mit niedriger Expression eine größere Varianz , weil die Stochastik bei kleinen Zahlen dominiert und die Messmethoden bei schwachen Signalen ungenauer sind

Wir wollen dann wissen, ob der LFC signifikant von Null abweicht.

Dazu wenden wir den Wald Test an. Der Wald Test kann angewandt werden, da folgende Vorraussetzhungen erfüllt sind: Wir haben genügend biologische Replikate, es gibt keine Ausreiser ( siehe Boxplot), die Verteilung der Daten folgt einer Negativen Bionominalverteilung.

Der Wald-Test prüft, ob der geschätzte Effekt (LFC) pro Gen signifikant von 0 abweicht.

Die rlog-Transformation dient dazu, die Zählwerte (Counts) aus RNA-Seq-Daten so umzuwandeln, dass sie für Visualisierungen und explorative Analysen besser geeignet sind – zum Beispiel für die PCA

[Unterschied normalisierte Daten und transformierte Daten]{.underline}

Das Ziel der Normalisierung ist die Korrektur für systematische Unterschiede in der Sequenzierungstiefe oder Library-Größe zwischen Proben.

Ziel der Transformation ist die Stabilisierung der Varianz für Visualisierung und Clustering (z. B. PCA, Heatmaps).Diese transformierten Counts werden nicht für die differentielle Analyse verwendet, sondern für Explorative Analysen wie PCA oder Clustering.

[Begriffe:]{.underline}

**Sequenztiefe** (auch: Sequenzierungstiefe oder auf Englisch *sequencing depth* bzw. *coverage*) ist ein Begriff aus der Genomforschung und beschreibt, wie oft ein bestimmter Bereich des Genoms bei einer Sequenzierung gelesen wurde.

Wenn ein DNA-Abschnitt 30-mal gelesen wurde, beträgt die Sequenztiefe 30x. Das bedeutet, dass im Durchschnitt jeder Basenpaar-Abschnitt 30 Mal abgedeckt wurde.

**Genlänge** bezeichnet die Anzahl der Basenpaare (bp), aus denen ein bestimmtes Gen besteht – also wie lang die DNA-Sequenz eines Gens ist.

[Warum weisen Gene mit niedriger Expression eine größere Variabilität auf ?]{.underline}

Gene mit niedriger Expression haben eine größere Varianz, weil die Stochastik bei kleinen Zahlen dominiert und die Messmethoden bei schwachen Signalen ungenauer sind

### QC Plot vor und nach der Normalisierung

Zur besseren Interpretation und dem Verständnis der Normalisierung bietet es sich an die Count-Werte der einzelnen Gene als kombinierten Boxplot für die jeweiligen Bedingungen darzustellen; jeweils vor und nach der Normalisierung. Die Konvertierung der Count-Werte in `log2(count + 1)` hat sich in dieser Hinsicht bewährt.

**Erstellt bitte einen Boxplot mit den log-transformierten Counts vor und einen Boxplot nach der Normalisierung.**

Hinweis: Normalisierte Counts erhaltet ihr nach anwenden der `DESeq()` Funktion und der Extraktion der Werte mit `counts(ddsObject, normalized = TRUE)`. Generell empfielt sich **ggplot2** zum Zeichnen zu verweden, da es vielfälltige Möglichkeiten bietet und dadurch sehr ansehnliche Abbildungen erstellen kann. Um ein für ggplot2 passendes `data.frame` zu erstellen, können Pakete wie z.B. reshape2, dplyr, etc. hilfreich sein.

```{r}

# before normalization

tmp <- log2(countMat + 1)
tmp <- reshape2::melt(tmp)
boxplot_unnorm <- ggplot(
  tmp,
  aes(
      
    x = Var2,
    y = value,
    fill = Var2
  )
) +
  geom_boxplot() +
  scale_fill_viridis(
    discrete = TRUE,
    option = "D"
  ) +
  theme_bw() + 
  labs(
    title = "raw counts",
    x = "sample",
    y = "log2(count + 1)",
    fill = "sample"
  )

tmp2 <- log2(dds.counts + 1)
tmp2 <- reshape2::melt(tmp2)
boxplot_norm <- ggplot(
  tmp2,
  aes(
    x = Var2,
    y = value,
    fill = Var2
  )
) +
  geom_boxplot() +
  scale_fill_viridis(
    discrete = TRUE,
    option = "D"
  ) +
  theme_bw() + 
  labs(
    title = "normalized counts",
    x = "sample",
    y = "log2(count + 1)",
    fill = "sample"
  )


```

```{r}
par(mfrow=c(1,2), mar=c(8,4,2,1))

boxplot_unnorm
boxplot_norm
```

[Interpretation:]{.underline}

Man sieht, dass die normalierte Daten weniger Ausreißer aufzeigen. Die Variabilität der Daten ist kleiner gworden.

Insgesamt unterscheiden sich die normalierten Daten aber wenig von den Rohdaten. Vermutlich liegteine gute Datenqualität vor,

**PCA - Principal Component Analysis**

Bevor wir mit der tatsächlichen DEG-Analyse fortfahren berechnen wir eine PCA um einen ersten Eindruck von unseren Daten zu bekommen. Dazu verwenden wir die eben erstellten, normalisierten Expressionswerte (rlog-Werte). In der PCA sollen die Bedingungen als *"individuals"* betrachtet und die Gene als *"variables"*. Im Resultat soll jede Probe dargestellt und in seine Haupkomponenten zerlegt werden. Hierzu könnt ihr z.B. das Paket [FactoMineR](http://factominer.free.fr/factomethods/principal-components-analysis.html) verwenden. Bitte erstellt einen sog. *"Individuals Graph"* mit den Proben und den ersten beiden Hauptkomponenten als Achsen. Wenn ihr das FactoMineR Paket verwendet findet ihr diese Infos unter `pca$ind$coord`. Um einen visuell ansprechenderen Abbildung zu erhalten würde ich empfehlen die Abbildung wieder mit dem Paket **ggplot2** zu erstellen. Mit der Funktion `ggsave()` könnte ihr die mit ggplot2 erstellte Abbildung sehr einfach in ein geeignetes Format, z.B. PDF, png, etc. exportieren.

**Erstellt eine PCA und stellt diese als Abbildung im HTML Dokument dar.ngen für PCA wurden**

[*Voraussetzungen*]{.underline} *für die PCA wurden überprüft. Visuell kann man an den Boxplots erkennen, dass sich Mittelwert und Varianz der einzelnen Proben kaum unterscheiden. Maximum und Minimum der Proben sind ebenfalls jeweils fast gleich.*

```{r Voraussetzungen PCA prüfen}

##Boxplot zeigen, dass Daten skaliert,
#MW und Varianz für die Proben gleich sindalso für weitere Analyse geeignet sind
# Minimum und Masximum gleich
# Ausreiser gibt es nicht
# 1. Linearer Zusammenhang

#
#datensatz <- counts(dds)
datensatz <- rlog_matrix
pairs(datensatz)  # Streudiagrammmatrix

cor_matrix <- cor(datensatz)
print(cor_matrix)

# Oder mit ggcorrplot (ggplot-Stil)
library(ggcorrplot)
ggcorrplot(cor_matrix, lab = TRUE)

## ANTWORT: Es liegt Korrelation vor

## Ist Skalierung notwendig
mittelwerte <- apply(datensatz, 2, mean)  # Mittelwert für jede Spalte
variancen <- apply(datensatz, 2, var)    # Varianz für jede Spalte

# Ergebnis anzeigen
result <- data.frame(Mittelwert = mittelwerte, Varianz = variancen)

## Antwort: die Mittelwerte und Varianzen unterscheiden sich zwischen den Proben kaum,
## Vergleichbarkeit ist also gegeben
## Anmerkung: Führt man die Prüfung, ob Daten skaliert sind, mit den Rohdaten durch (counts),  kann man größere Schwankungen beobachten

## Überprüfen Minimum und Maximum
# Minimum und Maximum der Variablen berechnen
mins <- apply(datensatz, 2, min)
maxs <- apply(datensatz, 2, max)

```

```{r Durchführung KMO Test}
## KMO Test
install.packages("psych")
library(psych)
KMO(datensatz)

## Resulat: Werte für alle Spalten größer 0,8 


```

```         
```

```{r PCA erstellen Individuals Plot}
#Zeigt die Proben (z. B. Patienten, Zellen, Experimente) in den neuen PCA-Koordinaten (PC1, PC2, …).
#Dient dazu, Cluster, Ähnlichkeiten oder Ausreißer zu erkennen.

install.packages("FactoMineR")
install.packages("ggplot2")
install.packages("factoextra")  # optional für visuelle Extras

library(FactoMineR)
library(ggplot2)
library(factoextra)

# Verwende rlog Werte
# rlog-Transformation (nur zur Erinnerung)
 rlog_data <- rlog(dds, blind = TRUE)
 # rlog-Matrix extrahieren
expr_matrix <- assay(rlog_data)  # Gene = Zeilen, Proben = Spalten

# Transponieren: Proben als Zeilen, Gene als Spalten
expr_t <- t(expr_matrix)

#PCA mit Factor Mine 
# PCA durchführen mit Proben als Individuals
pca <- PCA(expr_t, graph = FALSE, scale.unit = TRUE)

#Indiciduals Graph Plotten

# Koordinaten der Proben auf den ersten beiden PCs extrahieren
ind_coords <- as.data.frame(pca$ind$coord)
ind_coords$Sample <- rownames(ind_coords)

# Optional: Metadaten hinzufügen (z.B. Bedingung, Gruppe)
metadata <- colData(rlog_data)  # falls vorhanden
ind_coords$Condition <- metadata$condition

# Plot mit ggplot2
ggplot(ind_coords, aes(x = Dim.1, y = Dim.2, label = Sample)) +
  geom_point(size = 3, color = "steelblue") +
  geom_text(vjust = -0.5, size = 3) +
  labs(title = "PCA – Individuals Graph (Proben)",
       x = paste0("PC1 (", round(pca$eig[1,2], 1), "%)"),
       y = paste0("PC2 (", round(pca$eig[2,2], 1), "%)")) +
  theme_minimal()

#Plot Exportieren


```

```{r Überprüfung PC anhand der Achsenbeschriftung}
# Achsenbeschriftung
pca$eig  # Zeigt Varianz und kumulierte Varianz jeder Dimension
#Faustregel: PC1 + PC2 sollten im Idealfall >50 % der Gesamtvarianz erklären, aber das hängt stark vom Datentyp ab.
# ANTWORT: Faustregel stimmt



```

```{r  Überprüfung PC durch Clustering nach Gruppen}


#Clustern die Proben erwartungsgemäß?
#Wenn du z. B. Kontroll- und Behandlungsgruppen hast, sollten sich ähnliche Proben gruppieren.
 condition = factor(rep(c(group),each = 2))

ggplot(ind_coords, aes(x = Dim.1, y = Dim.2, color = condition)) +
  geom_point()
# Anwort: nur bei SO ist Gruppierung erkennbar 



# Anwort: nur bei SO ist Gruppierung erkennbar 
```

```{r  Plot mit Gen Variablen}

# Verwende rlog Werte
# rlog-Transformation (nur zur Erinnerung)
 rlog_data <- rlog(dds, blind = TRUE)


high_var_genes <- head(order(apply(assay(rlog_data), 1, var), decreasing = TRUE), 15)
pca_subset <- PCA(t(assay(rlog_data)[high_var_genes, ]), graph = FALSE)
fviz_pca_biplot(pca_subset)


#ENSG00000227268	100144748	KLLN	killin, p53 regulated DNA replication inhibitor (zeigt nach unten)



```

```{r Scree Plot}
install.packages("factoextra")
library(factoextra)

#Scree Plot: Erklärt, wie viel jede PC beiträgt
fviz_eig(pca)
# Man sieht, dass die ersten beiden PC den meisten Teil der Varianz erklären  ( der größte Knick ist zwischen der ersten und der zweiten Komponente)

```

```{r }

pca <- PCA(
  t(rlds),
  graph = F,
  scale.unit = F
)
scores <- as.data.frame(pca$ind$coord)
scores$Condition <- targets$Condition
scores$labels <- targets$ID
pca_plot <- ggplot(
  data = scores,
  aes(
    x=Dim.1,
    y=Dim.2,
    color=Condition,
    label=labels
  )
) + 
  geom_point(size = 2) + 
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  geom_label_repel() + 
  scale_color_viridis(
    discrete = TRUE,
    option = "D"
  ) +
  labs(
    title = 'PCA',
    x = paste(
      'PC1',
      '(',
      round(
        pca$eig[1,2],2
      ),
      '%)'
    ),
    y = paste(
      'PC2',
      '(',
      round(
        pca$eig[2,2],2
      ),
      '%)'
    )
  )
ggsave(
  filename = file.path(
    analysisDir,
    "PCA.pdf"
  ),
  plot = pca_plot,
  device = "pdf",
  dpi = "retina"
)


```

```{r}
pca_plot

```

![](images/clipboard-1322382393.png)

[Interpretation PCA]{.underline}

-   Die PCA zeigt, dass die verschiedenen Behandlungen (DMSO, Sora, Tram) zu deutlich unterschiedlichen globalen Profilen führen. Die hohe Wiederholbarkeit der Sora-Proben spricht für eine robuste Wirkung. Die hohe Varianz bei Tram weist auf eine mögliche Heterogenität hin, die näher untersucht werden sollte.

    Mit statistischen Tests und Plot könnte man die gezeigte Analyse weiter überpüfen.

## Differentielle Expressions Analyse

Um die DEG-Analyse durchzuführen müssen wir noch definieren an welchen tatsächlichen Vergleichen wir interessiert sind. Dazu können wir uns eine sog. [Kontrast-Matrix](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#contrasts) erstellen. Folgende Vergleiche sind für uns interessant:

-   Sorafenib vs DMSO und
-   Trametinib vs DMSO,

da wir verstehen wollen, welchen Einfluss die beiden Inhibitoren auf unsere Zellen haben. Für beide Vergleiche bestimmen wir die DEGs und exportieren diese bis zu einem korrigierten (FDR) p-Wert \< 0.05 in eine Tabelle. Hierzu verwenden wir die Funktion `lfcShrink()`. Damit die Tabellen für unsere Kollaborationspartner besser verständlich werden ist es essentiell, dass die Gene mit allen IDs, hautpsächlich aber dem Symbol, in den Ergebnissen enthalten sind.

**Berechnet die DEGs für die beiden Vergleiche Sorafenib vs DMSO und Trametinib vs DMSO. Erstellt Tabellen, die die signifikanten Gene bis zu einem FDR-korrigierten p-Wert \< 0.05 beinhalten. Achtet hier darauf auch das Symbol in der Ergebnistabelle zu haben. Ansonsten fällt die Zuordnung der Gene schwer. Zeigt diese im HTML Dokument. Exportiert die Ergebnisse der DEG-Analyse zusätzlich als Excel-Tabellen.**

Bei der Darstellung der DEG-Ergebnisse innerhalb des HTML Dokuments müsst ihr nicht alle Spalten darstellen. Dies wird schnell sehr unübersichtlich. Ich würde sagen, dass ihr maximal drei Angaben braucht: Symbol, log2FoldChange und den korrigierten p-Wert. Bei der Darstellung innerhalb des HTMLs kann die Funktion `kable()` hilfreich sein.

**Wie viele Gene sind pro Vergleich signifikant reguliert? Wie verteilt sich die Anzahl auf hoch- bzw. runter-regulierte Gene? Stellt diese Ergebnisse anschaulich dar.**

Hinweis: Hierzu könnt ihr den `log2FoldChange` aus der DEG-Analyse verwenden.

```{r}
# contrast matrix
contMat <- matrix(
  c('Sorafenib', 'DMSO',
    'Trametinib','DMSO'
    ),
  ncol = 2,
  byrow = TRUE
)
contMat <- cbind("Condition", contMat)                   

contName <- apply(
  contMat,
  1,
  function(i) {
    paste(i[2], i[3], sep = "-")
  }
)


# extracting the gene information
dds.ann.gene <- as.data.frame(rowData(dds))
install.packages("ashr")


# Sorafenib vs DMSO
resLFC_sora_dmso <- lfcShrink(dds, contrast=contMat[1,], parallel = T, type = "ashr")
resLFC_sora_dmso <- cbind(dds.ann.gene[, c("ENTREZ", "Symbol", "Genename", "ENSEMBL")], resLFC_sora_dmso)
resLFC_sora_dmso.final <- resLFC_sora_dmso[which(resLFC_sora_dmso$padj <= 0.05 & abs(resLFC_sora_dmso$log2FoldChange) >= 0), ]

# Trametinib vs DMSO
resLFC_tram_dmso <- lfcShrink(dds, contrast=contMat[2,], parallel = T, type = "ashr")
resLFC_tram_dmso <- cbind(dds.ann.gene[, c("ENTREZ", "Symbol", "Genename", "ENSEMBL")], resLFC_tram_dmso)
resLFC_tram_dmso.final <- resLFC_tram_dmso[which(resLFC_tram_dmso$padj <= 0.05 & abs(resLFC_tram_dmso$log2FoldChange) >= 0), ]


```

[Exkurs: Wald Test]{.underline}

Für jedes Gen schätzt DESeq2 ein negativ-binomiales Modell, typischerweise so:

log2(count) = a + b x Bedingung

b​ ist der log2-Fold-Change zwischen den Bedingungen.

Damit erhalten wir folgendes Test-Modell:

N**ullhypothese: b = 0 ( es gibt keinen Unterschied)**

**Alternativhypothese: b \<\> 0 ( Unterschied in der Genexpression zwischen beiden Gruppen )**

Dazu berechnen wir eine Teststatistik gemäß : LFC/ lfcSE , wobei lfcSE dabei die Standardabweichung des Log Fold Changes bedeutet.

Der *p-Wert* ist dann die Wahrscheinlichkeit, unter der Nullhypothese eine Teststatistik mindestens so extrem wie den beobachteten Wert zu erhalten.

Auch diese p Werte werden von DESeq2 berechnet. In unserem Beispiel beträgt p = 0.05

Wenn man viele Gene gleichzeitig testet (typisch bei RNA-Seq tausende Gene), steigt die Wahrscheinlichkeit, dass einige Tests nur zufällig signifikant sind (Fehler 1. Art, auch „False Positives“ genannt).

Da wir viele Gene testen, machen wir bei jedem einzelnen Test einen Fehler ( Fehler 1. Art: )

Fehler 1. Art bedeutet, dass wir die Nullhypothese ablehnen, obwohl sie wahr gewesen wäre. Wir erkennen als fälschlischerweise einen Unterschied in der Genexpression, der gar nicht besteht. Diese Fehler addieren sich, wenn man mehrere Tests durchfühert. Den Fehler müssen wir aber klein halten. Es hätte nicht unbedeutende Folgen, wenn wir einen Unterschied in der Genexpression aufzeigen , den es in Wirklichkeit gar nicht gibt. Daher betrachten wir den *adjustierten p Wert*, der die Problematik der Kummulation des alpha Fehlers mit berücksichtigt.

Da padj sehr klein ist betrachten wir den Zehnerlogarithmus von. Dieser ist negativ. Für Vulkano Plot zum Besipiel wird daher - log10 auf der y Achse aufgetragen

```{r}
resLFC_sora_dmso.final.down <- resLFC_sora_dmso[which(resLFC_sora_dmso$padj <= 0.05 & resLFC_sora_dmso$log2FoldChange <= 0), ]
resLFC_tram_dmso.final.down <- resLFC_tram_dmso[which(resLFC_tram_dmso$padj <= 0.05 & resLFC_tram_dmso$log2FoldChange <= 0), ]

resLFC_sora_dmso.final.up <- resLFC_sora_dmso[which(resLFC_sora_dmso$padj <= 0.05 & resLFC_sora_dmso$log2FoldChange  > 0), ]
resLFC_tram_dmso.final.up <- resLFC_tram_dmso[which(resLFC_tram_dmso$padj <= 0.05 & resLFC_tram_dmso$log2FoldChange  > 0), ]

```

```         
```

```{r}

cat(" Sora UP: ",nrow(resLFC_sora_dmso.final.up))
cat(" \n Sora DOWN : ",nrow(resLFC_sora_dmso.final.down))
cat(" \n Tram UP: ",nrow(resLFC_tram_dmso.final.up))
cat(" \n Tram DOWN : ",nrow(resLFC_tram_dmso.final.down))


```

Anzahl Gene, die von Sora hochreguliert werden: 1541

Anzahl Gene, die von Sora herunterreguliert werden: 2014

Anzahl Gene, die von Tram hochreguliert werden: 258

Anzahl Gene, die von Tram herunterreguliert werden: 546

```{r}

```

```{r}
so_up_anz <- nrow(resLFC_sora_dmso.final.up)
so_down_anz <- nrow(resLFC_sora_dmso.final.down)

tr_up_anz <- nrow(resLFC_tram_dmso.final.up)
tr_down_anz <- nrow(resLFC_tram_dmso.final.down)
gruppen <- c("Sora","Tram")
# Daten in ein DataFrame umwandeln
daten <- data.frame(
  Gruppe = rep(gruppen, each = 2),
  
  Regulation = rep(c("up", "down"), times = 2),
  Anzahl = c(so_up_anz,so_down_anz,tr_up_anz,tr_down_anz))


# Balkendiagramm
ggplot(daten, aes(x = Gruppe, y = Anzahl, fill = Regulation)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = Anzahl), 
            position = position_dodge(width = 0.9), 
            vjust = -0.3) +
  labs(
    title = "Verteilung der differentiell exprimierten Gene",
    x = "Behandlungsgruppe",
    y = "Anzahl Gene"
  ) + 
  scale_fill_manual(values = c("blue", "pink")) +
  theme_minimal()





```

#### ![](images/clipboard-4016379193.png)**Verhältnis "down" vs. "up"**:

-   

-   In **beiden Gruppen überwiegt die Herunterregulation**.

    Sora: 2014 "down" vs. 1541 "up" (\~57% vs. 43%)

    Tram: 546 "down" vs. 258 "up" (\~68% vs. 32%)

    -   Dies deutet darauf hin, dass **beide Wirkstoffe eher repressive Effekte auf die Genexpression** haben – stärker bei **Trametinib**.

### Identifizierte DEGs als Tabellen

#### Sorafenib vs. DMSO

```{r}
library(knitr)

df_up <- resLFC_sora_dmso.final.up%>% 
mutate(log2FoldChange_new = format(log2FoldChange, digits = 2)) %>% 
  mutate(padj_new = format(padj, scientific = TRUE, digits = 2))
names(df_up)
df_up_sort <-df_up[order(df_up$padj, decreasing = FALSE), ]
  
df_down <- resLFC_sora_dmso.final.down%>% 
mutate(log2FoldChange_new = format(log2FoldChange, digits = 2)) %>% 
  mutate(padj_new = format(padj, scientific = TRUE, digits = 2))
df_down_sort <-df_down[order(df_down$padj, decreasing = FALSE), ]


#resLFC_sora_dmso.final.down
cat("<h2>Signifikant hochregulierte Gene Sora versus DMSO</h2>")

kable(df_up_sort[,c("Symbol", "log2FoldChange_new", "padj_new")], row.names = FALSE, "html", col.names = c("Symbol(H )", "log2FC", "adj. p-value")) %>%
  kable_styling() %>% scroll_box(width = "100%", height = "800px")

cat("<h2>Signifikant runter regulierte Gene Sora versus DMSO</h2>")

kable(df_down_sort
      [,c("Symbol", "log2FoldChange_new", "padj_new")], row.names = FALSE, "html", col.names = c("Symbol(R-Gene)", "log2FC", "adj. p-value")) %>%
  kable_styling() %>% scroll_box(width = "100%", height = "800px")

  
```

[Anmerkung]{.underline}

Tabelle mit den unter Sora runterregulierten Genen ist nach adj. p Wert sortiert (Signifikanz). TNS4 weist eine hochsignifikante Veränderung der Genexpression (Runterregulation) auf, ebenso das MYC Gen (Protoonkogen, wird herunterreguliert).

Die Zahlen der Tabelle werden auch graphisch in denVulcano Plots Sichtbar.

#### Trametinib vs. DMSO

```{r}
df_up <- resLFC_tram_dmso.final.up%>% 
mutate(log2FoldChange_new = format(log2FoldChange, digits = 2)) %>% 
  mutate(padj_new = format(padj, scientific = TRUE, digits = 2))


df_down <- resLFC_tram_dmso.final.down%>% 
mutate(log2FoldChange_new = format(log2FoldChange, digits = 2)) %>% 
  mutate(padj_new = format(padj, scientific = TRUE, digits = 2))
df_up_sort <-df_up[order(df_up$padj, decreasing = FALSE), ]
df_down_sort <-df_down[order(df_down$padj, decreasing = FALSE), ]
  
  


#resLFC_sora_dmso.final.down
kable(df_up_sort[,c("Symbol", "log2FoldChange_new", "padj_new")], row.names = FALSE, "html", col.names = c("Symbol(H)", "log2FC", "adj. p-value")) %>%
  kable_styling() %>% scroll_box(width = "100%", height = "800px")

kable(df_down_sort[,c("Symbol", "log2FoldChange_new", "padj_new")], row.names = FALSE, "html", col.names = c("Symbol(R)", "log2FC", "adj. p-value")) %>%
  kable_styling() %>% scroll_box(width = "100%", height = "800px")


```

[Anmerkung:]{.underline}

Man erkennt mit Hilfe der Tabellen, dass es Gene gibt, die von Sora und Tram gemeinsam herunterreguliert werden (TNS4,FOSL1,KIAA0040)

### Visuelle Darstellung: Volcano Plot

Zusätzlich zur tabellarischen Darstellung der DEG-Ergebnisse kann man diese auch als sog. *"Volcano Plots"* darstellen. Dabei werden alle Gene als Punkte mit ihrem Signifikanzwert (y-Achse) und dem log2FoldChange (x-Achse) dargestellt. Die signifikanten Gene werden dabei farblich hervorgehoben. Mit dem R Paket [EnhancedVolcano](http://www.bioconductor.org/packages/release/bioc/vignettes/EnhancedVolcano/inst/doc/EnhancedVolcano.html) haben wir gute Erfahrungen gemacht.

**Erstellt jeweils einen Volcano Plot für die beiden Vergleiche.**

```{r}
 
volcano_sora <- EnhancedVolcano(
  resLFC_sora_dmso.final,
  lab = resLFC_sora_dmso.final$Symbol,
  x = 'log2FoldChange',
  y = 'padj',
  title = "Sorafenib vs. DMSO",
  subtitle = NULL,
  caption = paste0("total = ", nrow(resLFC_sora_dmso.final), " genes"),
  pCutoff = 0.05,
  FCcutoff = 0.5,
  pointSize = 3.0,
  labSize = 6.0,
  drawConnectors = FALSE,
  typeConnectors = "closed",
  endsConnectors = "last",
  arrowheads = FALSE,
  legendPosition = "top",
  gridlines.major = FALSE,
  gridlines.minor = FALSE,
  legendDropLevels = TRUE,
)


```

```{r}
head(resLFC_sora_dmso.final)

```

#### Volcano Plot: Sorafenib vs. DMSO

```{r}
volcano_sora

```

![](images/clipboard-1376388871.png)

Erläuterung:

-   **Blau**: Gene mit **signifikantem p-Wert**, aber ohne starken Fold Change.

-   **Rot**: Gene mit **signifikantem p-Wert UND starkem Fold Change** (also wirklich interessant für die Biologie).

<!-- -->

-   **TNS4**, **FOSL1**, **IER3**, **PHC2**, **CDKN1B**, **PCK1**

|  |  |  |  |  |
|----|----|----|----|----|
|  |  |  |  |  |
|  | **Gen** |  | **Funktion / Rolle** |  |
|  |  |  |  |  |
|  | **TNS4 (Tensin 4)** |  | Beteiligt an Zellmigration und Zelladhäsion, häufig überexprimiert in Tumoren. |  |
|  |  |  |  |  |
|  | **FOSL1 (FOS-like 1)** |  | Transkriptionsfaktor, Teil des AP-1-Komplexes, beeinflusst Zellproliferation und Tumorprogression. |  |
|  |  |  |  |  |
|  | **IER3 (Immediate Early Response 3)** |  | Stressantwortgen, schützt Zellen vor Apoptose, kann bei Krebs eine Rolle spielen. |  |
|  |  |  |  |  |
|  | **SPRY4 (Sprouty RTK signaling antagonist 4)** |  | Negativer Regulator von Wachstumsfaktor-Signalen (MAPK), tumorunterdrückende Funktion. |  |
|  |  |  |  |  |
|  | **PHC2 (Polyhomeotic homolog 2)** |  | Teil des Polycomb-Komplexes, reguliert epigenetisch die Genexpression. |  |
|  |  |  |  |  |
|  | **RP8** *(unklar, evtl. Schreibfehler oder weniger bekanntes Gen)* |  | Könnte sich um ein RNA-bindendes Protein handeln – bitte bei Rohdaten prüfen. |  |
|  |  |  |  |  |
|  | **FGF19 (Fibroblast Growth Factor 19)** |  | Regulator von Zellwachstum und -stoffwechsel, wird in manchen Tumoren überexprimiert. |  |
|  |  |  |  |  |
|  | **FER1L4 (Fer-1 Like Family Member 4, pseudogene/lincRNA)** |  | Long non-coding RNA, wirkt vermutlich als Tumorsuppressor in bestimmten Krebsarten. |  |
|  |  |  |  |  |

-   Gene aus Aufgabenstellung sind allerdings nicht dabei

-   

    ### Alternative Darstellung Vulcano-Plot ( Sora gegen DMSO)

    ```{r}
    head(resLFC_sora_dmso.final)
    ```

    ```{r Vorbereitung Vulcano}
    get_vul_daten <- function (df_daten) {
      #df_sel <- data.frame(df_daten[, 2], df_daten[, 3], df_daten[, 5])
       df_sel <- data.frame(df_daten[, 4],df_daten[, 6], df_daten[, 7], df_daten[, 9])
      df_sel %>%
        mutate(across(where(is.numeric), ~ replace_na(., 0))) %>%
        filter(df_daten[, 9] < 0.05)
      return(df_sel)
      
      
    }
    add_gene_id <- function(df, col_name = "ENSEMBL") {
     # for (i in 1:nrow(df)) {
    #    aktuelle_zeile_name <- rownames(df)[i]
        
    #  }
    #  df$ENSEMBL <- rownames(df)
      colnames(df) <- c("ENSEMBL","log2FoldChange", "lfcSE", "padj")
      return(df)
    }

    cleanTable <- function(df, anz_ges, probe) {
      df_up <- select(df, Symbol, log2FoldChange, padj)
      df_up_ohne_na <- drop_na(df_up)
      return (df_up_ohne_na)
    }


    ```

    ```{r}
    df_1 <- get_vul_daten(resLFC_sora_dmso.final)
    ##head(df_1)
    df_2 <- add_gene_id(df_1)

    df_3 <- inner_join(x = df_2,
                       y = geneMat,
                       by = c("ENSEMBL" = "ENSEMBL")) %>%
      select(ENSEMBL, Symbol, log2FoldChange, lfcSE, padj)

    df_4 <- cleanTable(df_3, nrow(resLFC_sora_dmso.final), "SO gegen DMSO")
    df_res_SO_vulc<- df_4%>% 
      mutate(minus_log10_p = -log10(df_4$padj)) 

    ```

    ```{r}
    library(ggplot2)
    library(ggrepel)
     alpha_val = 0.05

    # Erstelle den Volcano Plot
    ggplot(df_res_SO_vulc, aes(x=log2FoldChange, y=minus_log10_p)) +
      geom_point(alpha=0.6, size=1.5) +
      # Optional: Farben nach Signifikanz
      aes(color=padj < 0.05) +
      scale_color_manual(values=c("red", "gray")) +
      # Textlabels für signifikante Gene
      geom_text_repel(
        #data=subset(df_res_SO, padj < 0.001 & abs(log2FoldChange) > 1),
        data=subset(df_res_SO_vulc, padj < alpha_val & abs(log2FoldChange) > 1),
        aes(label=Symbol),
        size=3,
        max.overlaps=25
      )

    ```

    ```         
    ```

[Interpretation]{.underline}

-   **Runterreguliert (links)**:

    **TNS4**, **MYC**, **FOSL1** – diese Gene sind signifikant **weniger exprimiert**.

-   **Hochreguliert (rechts)**:

    **PCK1**, **NEU4**, **GPRIN2** – diese Gene sind signifikant **mehr exprimiert**.

## **Stark herunterregulierte Gene (links im Plot)**

Diese Gene haben **negative log2FoldChange-Werte** → ihre Expression ist **deutlich reduziert**.

| Gen | Bedeutung / Funktion | Mögliche Interpretation |
|----|----|----|
| **TNS4** | *Tensin 4* – beteiligt an Zelladhäsion und Zellmigration | Reduzierte Zellbeweglichkeit |
| **FOSL1** | *Transkriptionsfaktor, AP-1-Komplex* | Hemmung von Zellwachstum oder Stressantwort |
| **MYC** | Proto-Onkogen, zentraler Regulator des Zellwachstums | **Sehr relevant** – häufig bei Krebs überexprimiert; Herunterregulierung könnte antiproliferativ wirken |
| **DUSP4/DUSP2** | *Dual-specificity Phosphatase* – hemmen MAPK-Signalwege | Regulieren Zellteilung und Immunantwort; Runterregulierung → gestörte Signalverarbeitung |
| **ETV5 / EGR1 / SPRY4** | Transkriptionsfaktoren oder Signalwegregulatoren (z. B. FGF/MAPK) | Kontrollieren Differenzierung, Wachstum; verminderte Aktivität könnte Differenzierung hemmen |
| **LIF** | *Leukemia Inhibitory Factor* – Zytokin, wirkt auf Stammzellnischen | Weniger LIF → reduzierte Stammzellaktivität oder Differenzierung |

## **Stark hochregulierte Gene (rechts im Plot)**

Diese Gene haben **positive log2FoldChange-Werte** → ihre Expression ist **deutlich erhöht**.

| Gen | Bedeutung / Funktion | Mögliche Interpretation |
|----|----|----|
| **PCK1** | *Phosphoenolpyruvat-Carboxykinase* – wichtig in der Glukoneogenese (Zuckerneubildung) | Hinweis auf metabolische Umstellung, z. B. bei Fasten, Diabetes oder Tumorzellen |
| **NEU4** | *Neuraminidase 4* – spielt eine Rolle bei der Zellmembran-Modifikation | Kann Signalverarbeitung oder Immunantwort beeinflussen |
| **GPRIN2** | *G Protein-Regulated Inducer of Neurite Outgrowth* | Beteiligung an neuronaler Entwicklung oder Signalübertragung |
| **RBBP8NL** | *Chromatin-assoziiertes Protein* | Möglicherweise epigenetische Regulation |
| **CDX2** | *Transkriptionsfaktor, wichtig in der Darmentwicklung* | Hochreguliert in manchen Tumoren oder Differenzierungsprozessen |
| **CYP1A1** | *Cytochrom P450* – Detoxifikation, Stoffwechsel von Xenobiotika | Hochregulation → Reaktion auf Toxine oder Umwelteinflüsse |
| **BNIP5 / BMF** | *Pro-apoptotische Gene* | Könnte auf gesteigerte Apoptose (Zelltod) hinweisen |

#### Volcano Plot: Trametinib vs DMSO

```{r}
volcano_tram <- EnhancedVolcano(
  resLFC_tram_dmso.final,
  lab = resLFC_tram_dmso.final$Symbol,
  x = 'log2FoldChange',
  y = 'padj',
  title = "Trametinib vs. DMSO",
  subtitle = NULL,
  caption = paste0("total = ", nrow(resLFC_tram_dmso.final), " genes"),
  pCutoff = 0.05,
  FCcutoff = 0.5,
  pointSize = 3.0,
  labSize = 6.0,
  drawConnectors = FALSE,
  typeConnectors = "closed",
  endsConnectors = "last",
  arrowheads = FALSE,
  legendPosition = "top",
  gridlines.major = FALSE,
  gridlines.minor = FALSE
)

volcano_tram

```

![](images/clipboard-4070332211.png)[Erläuterung des Plots:]{.underline}

Vergleich der Genexpression zwischen Zellen, die mit Trametinib (ein MEK-Inhibitor) behandelt wurden, und Zellen mit DMSO (Kontrolle).

Auf der x-Achse ist der Log₂-Fold Change (log₂FC) abgetragen- Positive Werte bedeuten, dass die Gene hochreguliert unter Trametinib werden. Negative Werte bedeuten, dass die Gene unter Tram herunterreguliert unter Trametinib

**Auf der Y-Achse** ist –log₁₀(p-Wert) abgetrageb\
→ Zeigt die statistische Signifikanz der Unterschiede:

-   Höherer Wert = **stärker signifikant**

-   **Blaue Punkte**: Gene, die **nur basierend auf dem p-Wert** signifikant sind

-   **Rote Punkte**: Gene, die **sowohl basierend auf dem p-Wert als auch auf dem log₂-Fold Change** signifikant sind

-   Folgende Gene sind besonders zu beachten:

    -   <div>

        | Gen | Regulation |
        |-----|------------|

        </div>

        |          |                   |
        |----------|-------------------|
        | **TNS4** | herunterreguliert |

        |           |                   |
        |-----------|-------------------|
        | **FOSL1** | herunterreguliert |

        |              |                   |
        |--------------|-------------------|
        | **KIAA0040** | herunterreguliert |

        |          |               |
        |----------|---------------|
        | **CDX2** | hochreguliert |

        |               |               |
        |---------------|---------------|
        | **ARHGEF10L** | hochreguliert |

    [Erläuterung der relevanten Gene:]{.underline}

    **TNS4** (auch bekannt als Tensin 4 oder CTEN) ist ein Gen, das ein Protein produziert, das bei folgenden Prozessen eine Rolle spielt:Zelladhäsion und Zellwanderung (wichtig z. B. bei der Wundheilung oder Krebsbildung), Tumorentwicklung, insbesondere bei Darmkrebs und Magenkrebs. Das Gen gehört zur Tensin-Proteinfamilie, die mit Zell-Zell-Kontakten und Signalübertragung in Verbindung steht. In der Krebsforschung ist TNS4 von besonderem Interesse, da es mit der Metastasierung (Ausbreitung von Tumorzellen) in Zusammenhang stehen.

    **FOSL1** ist ein Teil des sogenannten AP-1-Komplexes (Activator Protein 1), der aus Proteinen der FOS- und JUN-Familien besteht. Der AP-1-Komplex reguliert die Transkription von Genen, die an wichtigen zellulären Prozessen beteiligt sind: Zellwachstum, Zellteilung (Prolieferation), Zelldifferenzierung, Entzünfungsreaktion, Zelltod (Apoptose). FOSL1 ist in vielen Tumorarten überaktiv, z. B. bei: Brustkrebs, Darmkrebs,Glioblastomen, Melanomen. Es wird deshalb als Onkogen (krebsförderndes Gen) betrachtet.Überexpression von FOSL1 kann zur Erhöhung der Invasivität und Metastasierung von Krebszellen führen.

-   **KIAA0040** ist ein menschliches Gen, das noch nicht vollständig charakterisiert ist. Es gehört zu einer Gruppe von Genen, die ursprünglich im Rahmen des KIAA-Projekts in Japan entdeckt wurden, bei dem große offene Leserahmen (Open Reading Frames, ORFs) sequenziert wurden, ohne dass man anfangs ihre Funktion kannte.

    **CDX2** ist ein gut untersuchtes Gen, das für einen Transkriptionsfaktor kodiert und eine wichtige Rolle in der Embryonalentwicklung sowie im Darmepithel spielt.

-   **ARHGEF10L** (vollständig: Rho Guanine Nucleotide Exchange Factor 10 Like) ist ein menschliches Gen, das ein Rho-GEF-Protein (Guanin-Nukleotid-Austauschfaktor) kodiert. Es gehört zur Familie der RhoGEFs, die eine wichtige Rolle in der Signalübertragung innerhalb der Zelle spielen – insbesondere bei der Regulation des Zytoskeletts, der Zellform, Zellbewegung und Zellproliferation.

    Gene aus Aufgabenstellung sind allerdings nicht dabei

    ### Alternative Darstellung Vulcano Plot Tram versus DMSO

    ```{r}
    df_1 <- get_vul_daten(resLFC_tram_dmso.final)
    ##head(df_1)
    df_2 <- add_gene_id(df_1)

    df_3 <- inner_join(x = df_2,
                       y = geneMat,
                       by = c("ENSEMBL" = "ENSEMBL")) %>%
      select(ENSEMBL, Symbol, log2FoldChange, lfcSE, padj)

    df_4 <- cleanTable(df_3, nrow(resLFC_sora_tram.final), "Tram gegen DMSO")
    df_res_TR_vulc<- df_4%>% 
      mutate(minus_log10_p = -log10(df_4$padj)) 


    ```

    ```{r}
     alpha_val = 0.05

    # Erstelle den Volcano Plot
    ggplot(df_res_TR_vulc, aes(x=log2FoldChange, y=minus_log10_p)) +
      geom_point(alpha=0.6, size=1.5) +
      # Optional: Farben nach Signifikanz
      aes(color=padj < 0.05) +
      scale_color_manual(values=c("red", "gray")) +
      # Textlabels für signifikante Gene
      geom_text_repel(
        #data=subset(df_res_SO, padj < 0.001 & abs(log2FoldChange) > 1),
        data=subset(df_res_TR_vulc, padj < alpha_val & abs(log2FoldChange) > 1),
        aes(label=Symbol),
        size=3,
        max.overlaps=25
      )
    ```

-   ![](images/clipboard-1818684831.png)

    <div>

    ## Vergleich der beiden Medikamente

    </div>

Um die Unterschiede und Gemeinsamkeiten zwischen den beiden Medikamenten bzw. deren jeweilligen Vergleiche zu DMSO zu finden, können wir das R Paket [UpSetR](https://github.com/hms-dbmi/UpSetR) verwenden. Da wir beide Medikament zu DMSO verglichen habenist das Vorgehen sinnvoll und wir können direkt Unterschiede und Gemeinsamkeiten identifizieren. Wir nehmen den Vergleich auf Ebene der signifikant regulierten Gene, getrennt nach hoch- bzw. runter-Regulation, vor. Dazu legen wir uns zwei Listen an, analog zu [Basic Usage](https://cran.r-project.org/web/packages/UpSetR/vignettes/basic.usage.html). Eine für die hoch-regulierten und eine für die runter-regulierten Gene. Danach kann der Befehl `upset(fromList(list))` verwendet werden. Um an die einzelnen Gene in den verschiedenen *"Sets"* zu kommen, stellen wir euch eine Funktion `upSetSets(list)` zur Verfügung. Als Input Parameter übergebt ihr dieser Funktion die Liste, die auch für `upset()` verwendet wird.

**Führt den Vergleich der beiden Medikamente durch.**

```{r}
# function to obtain genes per set
upSetSets <- function(sets){
  list_names <- names(sets)
  attach(sets,warn.conflicts = F)
  res <- lapply(1:length(list_names),function(y){
    combinations <- combn(list_names,y)
    res<-as.list(apply(combinations,2,function(x){
      if(length(x)==1){
        p <- setdiff(get(x),unlist(sapply(setdiff(list_names,x),get)))
      }

      else if(length(x) < length(list_names)){
        p <- setdiff(Reduce(intersect,lapply(x,get)),
        Reduce(union,sapply(setdiff(list_names,x),get)))
      }

      else p <- Reduce(intersect,lapply(x,get))

      if(!identical(p,character(0))) p
      else NA
    }))

    if(y==length(list_names)) {
      res[[1]] <- unlist(res);
      res<-res[1]
    }
    names(res) <- apply(combinations,2,paste,collapse="-")
    res
  })
  result <- lapply(res, function(x) x[!is.na(x)])
  result <- unlist(result, recursive = F)
  result <- lapply(result,function(x) data.frame(ID=x))
  return(result)
  detach(sets)
}

```

```{r}
deg_up <- list(
  Sorafenib_vs_DMSO = c(resLFC_sora_dmso.final.up$ENSEMBL),
Trametinib_vs_DMSO = c(resLFC_tram_dmso.final.up$ENSEMBL)
)

deg_down <- list(
  Sorafenib_vs_DMSO = c(resLFC_sora_dmso.final.down$ENSEMBL),
  Trametinib_vs_DMSO = c(resLFC_tram_dmso.final.down$ENSEMBL)
)
upset_plot_up <- upset(fromList(deg_up))
upset_out_up <- upSetSets(deg_up)


df_set_hoch_beide_ens <-data.frame(upset_out_up[[3]])  
colnames(df_set_hoch_beide_ens) <- c('ENSEMBL')                                   
df_set_up_both <- inner_join(x = df_set_hoch_beide_ens,
                   y = geneMat,
                   by = c("ENSEMBL" = "ENSEMBL"))

df_set_runter_beide_ens <-data.frame(upset_out_down[[3]])  
colnames(df_set_runter_beide_ens) <- c('ENSEMBL')        
df_set_down_both <- inner_join(x = df_set_runter_beide_ens,
                   y = geneMat,
                   by = c("ENSEMBL" = "ENSEMBL"))



```

```{r}
names(upset_out_up)

```

```{r}
#names(upset_out_up)
df_sora_up_ens <-data.frame(upset_out_up[[1]])  
colnames(df_sora_up_ens) <- c('ENSEMBL')        
df_sora_up <- inner_join(x = df_sora_up_ens,
                   y = geneMat,
                   by = c("ENSEMBL" = "ENSEMBL"))


df_sora_down_ens <-data.frame(upset_out_down[[1]])  
colnames(df_sora_down_ens) <- c('ENSEMBL')        
df_sora_down <- inner_join(x = df_sora_down_ens,
                   y = geneMat,
                   by = c("ENSEMBL" = "ENSEMBL"))
```

```{r}
df_tram_up_ens <-data.frame(upset_out_up[[2]])  
colnames(df_tram_up_ens) <- c('ENSEMBL')        
df_tram_up <- inner_join(x = df_tram_up_ens,
                   y = geneMat,
                   by = c("ENSEMBL" = "ENSEMBL"))


df_tram_down_ens <-data.frame(upset_out_down[[2]])  
colnames(df_tram_down_ens) <- c('ENSEMBL')        
df_tram_down <- inner_join(x = df_tram_down_ens,
                   y = geneMat,
                   by = c("ENSEMBL" = "ENSEMBL"))



```

```         
```

### Gemeinsamkeiten

#### Durch beide Medikamente hoch-regulierte Gene

```{r}

upset_plot_up


```

![](images/clipboard-3762531266.png)

[Interpretation]{.underline}

-   **Sorafenib** enthält die meisten Elemente (ca. 1500).

-   **Trametinib** ist deutlich kleiner (ca. 200).

-   Die **gemeinsame Schnittmenge** beträgt **241**, was relativ groß ist im Verhältnis zur Gesamtgröße von Trametinib (d. h. \> 100 % – vermutlich doppelte Zählung oder ein anderer Referenzrahmen?).

-   **Nur 12 Gene** sind **spezifisch für Trametinib**, und **1295 Gene** sind **spezifisch für Sorafenib**.

-   **Mögliche Bedeutung (z. B. bei Genanalysen):**

    Viele Gene, die bei **Trametinib** reguliert sind, werden **auch bei Sorafenib** reguliert → potenzielle Gemeinsamkeiten in der Wirkweise.

    Es gibt jedoch auch **substanzspezifische Unterschiede**.s

-   

#### Durch beide Medikamente runter-regulierte Gene

```{r}
upset_plot_down
```

![](http://127.0.0.1:37555/chunk_output/608A17CA99518554/A0FD2F1C/czhbmk5gkvqzc/000010.png)

[Interpretation]{.underline}

nur von Sora runterregulierte Gene: 1500

nur von Tram runterregulierte Gene: 32

von Sora und Tram runterregulierte Gene: 514

1500 + 514 = 2014 (Gene , die von Sora herunterreguliert werden)

514 + 32 = 546 (Gene , die von Tram herunterreguliert werden)

Was wir oben auch schon gesehen haben. Konsistenz liegt vor

-   **Sorafenib_vs_DMSO** enthält die meisten differentiell exprimierten Gene (ca. 2000), davon **1500 nur in dieser Gruppe**.

<!-- -->

-   **Trametinib_vs_DMSO** hat ca. 600 Gene, davon **514 exklusiv**. Nur **32 Gene sind in beiden Gruppen gemeinsam differentiell exprimiert** – dies deutet auf relativ unterschiedliche Wirkmechanismen oder Genantworten der beiden Wirkstoffe hin.

Jetzt kennen wir die Gene, die entweder durch beiden Medikamente oder auch nur in dem einen oder dem anderen verändert sind. Aber was machen wir jetzt damit? Wir können uns z.B. der Ressource *"Molecular Signatures Database"* (MSigDB) bedienen.

"MSigDB is a resource of tens of thousands of annotated gene sets for use with GSEA (gene-set enrichment analysis) software".

Die "gene-set enrichment" Analyse ist eine Berechnungsmethode, mit der festgestellt wird, ob ein a priori definierter Satz von Genen statistisch signifikante, übereinstimmende Unterschiede zwischen zwei biologischen Zuständen (z.B. Phänotypen) zeigt. Anders ausgedrückt können wir damit bestimmen, ob die Gene innerhlab der oben bestimmten *"Sets"* einen signifikante "Funktion" haben und daraus schlußfolgern, dass diese "Funktion" in unserem Experiment verändert ist. Für die Analyse verwenden wir den Exakten Test nach Fisher oder auch hypergeometrischer Test. Die Funktion `hyperG()` für den Test stellen wir euch zur Verfügung.

```{r}
hyperG <- function(geneSets,DEgenes,universe, cutoff=0.1, mincount=2, parallel=T, adj.P.Val = F,
                   set.size = NULL){
  #' hyperG
  #' 
  #' @description Calculates Fisher's Exact test with the specified genes and the supplied gene-sets.
  #'
  #' @param geneSets list. Gene-Set the calculation is based on, e.g. go.bp
  #' @param DEgenes character vector. Gene IDs used for testing. Same identifiers as used for the gene-sets, e.g. ENTREZ IDs.
  #' @param universe character vector. Universe gene IDs.
  #' @param cutoff numeric. Cutoff used to identify sig. pathways. Default: 0.1.
  #' @param mincount numeric. Consider only pathways which contain at least mincount genes. Default: 2
  #' @param parallel boolean. Use parallel calculation. Default: TRUE
  #' @param adj.P.Val boolean. Use adjusted p-value for significance filtering. Is always calculated.
  #' @param set.size vector. Min and max size of allowed gene-sets. Default min:10 genes and max:500 genes.
  #'  
  #' @return the significant regualted pathways.
  #' @export
  #' @importFrom foreach, doMC
  
  require(foreach)
  require(doMC)
  if(parallel){
    registerDoMC(cores=detectCores())
    cores=detectCores()
  }else{
    cores=1
  }
  if(!is.null(set.size)){
    print('Set Size Limits')
    idx <- lapply(geneSets,function(x){length(x) <= set.size[2] & length(x) >= set.size[1]})
    geneSets <- geneSets[unlist(idx)]
  }
  l <- length(setdiff(universe,DEgenes))
  DElen <- length(DEgenes)
  results <- mclapply(1:length(geneSets), function(i){
    results <- matrix(data=NA,ncol=7,nrow = 1)
    colnames(results) <- c('Term','Count','Size','p-value','adj.P.Val','odds ratio','GeneIDs')
    geneSet <- intersect(universe, geneSets[[i]])
	e <- intersect(DEgenes,geneSet)
    a <- length(e)
    b <- DElen - a
    c <- length(geneSet) - a
    d <- l - c
    contigency.matrix <- cbind(c(a,b),c(c,d))
    res <- fisher.test(contigency.matrix,alternative = 'greater')
    results[1,'Term'] <- names(geneSets)[i]
    results[1,'Count'] <- a
    results[1,'Size'] <- length(geneSets[[i]])
    results[1,'p-value'] <- res$p.value
    results[1,'odds ratio'] <- res$estimate[[1]]
    # find genes annotated in the consensus term
    if(a > 0){
      genes <- intersect(DEgenes,geneSet)
      eid <- genes
      eid <- eid[order(eid)]
      results[1,'GeneIDs'] <- paste(eid,collapse="|")
    }
    return(results)
  }, mc.cores=cores)
    
  results <- as.data.frame(do.call(rbind, results))
  for(i in c(2, 3, 4, 5)){
    results[, i] <- as.numeric(as.character(results[, i]))
  }
  
  if(nrow(results) != 1){
    results <- results[order(results[,'p-value'],decreasing = FALSE),]
	results[,'adj.P.Val'] <- p.adjust(results[,'p-value'], 'BH')
	if(adj.P.Val){
		results <- as.data.frame(subset(results,results[,'adj.P.Val']<=cutoff))
	}else{
		results <- as.data.frame(subset(results,results[,'p-value']<=cutoff))
	}
    results <- as.data.frame(subset(results,results[,'Count']>=mincount))
  }else results <- as.data.frame(results)
  
  return(results)
}


```

```{r}
plot_pathway <- function(hallmark, genset,universe,label,top, color,cut_off ){
  results<- hyperG(
  geneSets = hallmark,
  DEgenes = genset,
  universe = universe,
  cutoff = cut_off,            # z.B. ein strengerer cutoff
  mincount = 2,             # Mindestanzahl Gene pro Set
  parallel = FALSE,          # Parallele Berechnung
  adj.P.Val = TRUE         # Adjustierte p-Werte berücksichtigen
  #set.size = c(10, 500)     # Nur Sets mit 10–500 Genen berücksichtigen
)
  
  results <- results[order(results$adj.P.Val), ]

# Wähle die Top 10
top_results <- head(results, top)

ggplot(top_results, aes(x = reorder(Term, -adj.P.Val), y = -log10(adj.P.Val))) +
  geom_bar(stat = "identity", fill = color ) +
  coord_flip() +   # horizontale Balken
  labs(title = label,
       x = "Genset",
       y = "-log10(adjustierter p-Wert)") +
  theme_minimal()
}


```

```         
```

Außer der Funktion benötigen wir noch die entsprechenden Gensets/ Signalwegen, die uns interessieren. Diese können wir direkt über ein R Paket von MSigDB (msigdbr) beziehen. Auch hierzu stellen wir euch eine Funktion zur Verfügung, die das abrufen und erstellen der passenden Gensets vereinfacht. Wir laden uns damit die "Hallmark Gene Sets" direkt mit den *Gen-Symbolen* der Gene als IDs. Das geladene Genset ist eine Liste, die direkt als Input für die Funktion `hyperG()` verwendet werden können.

```{r}
get_geneset_ag <- function(
  species = "Homo sapiens",
  category = NULL,
  subcollection = NULL,
  format = "entrez"
) {
  require(msigdbr)
  db_df <- msigdbr(species = species ,category = category, subcollection = subcollection)
  if(format == "entrez"){
    m_list = db_df %>% split(x = as.character(.$entrez_gene), f = .$gs_name)
    for(idx in 1:length(m_list)){
      m_list[[idx]] <- unique(m_list[[idx]] )
    }
    return(m_list)
  }
  if(format == "symbol"){
    m_list = db_df %>% split(x = .$gene_symbol, f = .$gs_name)
    for(idx in 1:length(m_list)){
      m_list[[idx]] <- unique(m_list[[idx]])
    }
    return(m_list)
  }
  if(format == "df"){
    return(db_df)
  }
}
```

```{r}
# load Hallmark gene set
hallmark <- get_geneset_ag(species = "Homo sapiens", category = "H", format = "symbol")



```

Um die Funktion `hyperG()` ausführen zu können brauchen wir jetzt noch ein sog. *"universe"*. Dieses beinhaltet alle Gene, die in unserem Experiment enthalten sind. Das *"universe"* ist ein Vektor, der alle Gene als Symbole beinhaltet. Es sollten keine NAs und/ oder Duplikate enthalten sein.

**Erstellt das "universe" und führt die funktionelle Analye/ Gene-set Enrichment Analyse mit der hyperG Funktion und den Hallmark Signalwegen durch**

```{r}
library(parallel)
#universe <- na.omit(geneMat$Symbol)
ensembl_ids <- rownames(dds)
universe_df <- tibble(ENSEMBL = ensembl_ids) |>
         left_join(geneMat[, c("ENSEMBL", "Symbol")], by = "ENSEMBL")

universe <- universe_df$Symbol|> unique() 
universe <- universe |> na.omit()



```

#### Gemeinsamkeiten: Durch beide Medikamente hoch-regulierte Hallmark Gensets

```{r}

plot_pathway(hallmark, df_set_up_both$Symbol,universe,"Top 10 angereicherte Hallmarks von Tra und Sora", 10, "skyblue1" ,0.5)






```

```         
Anmerkung: Bei cutoff = 0.1 werden mir keine Pathways angezeigt
```

#### Gemeinsamkeiten: Durch beide Medikamente runter-regulierte Hallmark Gensets

```{r}
plot_pathway(hallmark, df_set_down_both$Symbol,universe,"Top 10 runter regulierte Hallmarks von Tra und Sora", 10, "skyblue1" ,0.1)


```

![](images/clipboard-1407208993.png)**Von Sorafenib herunterreguliert:**

```{r}

plot_pathway(hallmark, resLFC_sora_dmso.final.down$Symbol,universe,"Down regulierte Hallmark-Gensets von Sora", 10, "skyblue2",0.1 )
```

![](images/clipboard-3232411906.png)**Von Sorafenib hochreguliert:**

```{r}
plot_pathway(hallmark, resLFC_sora_dmso.final.up$Symbol,universe,"Top 10 angereicherte Hallmark-Gensets von Sora", 10, "skyblue2", 0.1 )
```

![](images/clipboard-3178670481.png)

**Von Trametinib hochreguliert:**

```{r}
plot_pathway(hallmark, resLFC_tram_dmso.final.up$Symbol,universe,"Angereicherte Hallmark-Gensets von Tram", 10, "skyblue2",0.5)
```

![](images/clipboard-858884559.png)

**Von Trametinib runterreguliert:**

```{r}
plot_pathway(hallmark, resLFC_tram_dmso.final.down$Symbol,universe,"Down regulierte Hallmark-Gensets von Tram", 10, "skyblue2",0.1)
```

![](images/clipboard-1530996741.png)

```{r}
common_up <- hyperG(

    geneSets = hallmark,
  #DEgenes = upset_out_up$`Sorafenib_vs_DMSO-Trametinib_vs_DMSO`$ID,
  DEgenes = df_set_up_both$Symbol,
  universe = universe,
  cutoff = 0.1,
  mincount = 2,
  parallel = F,
  set.size = c(10,500)
)
```

```{r}
df <- common_up
df$ratio <- df$Size / length(universe)
df_top <- df
df_top$Pathway <- gsub(pattern = "HALLMARK_ dutchh ", replacement = "", x = df_top$Term)
df_top <- df_top[order(df_top$ratio, decreasing = F), ]
df_top$Pathway <- factor(df_top$Pathway, levels = df_top$Pathway)
df_top$logP <- -log10(df_top$adj.P.Val)
df_top$logP[df_top$logP == Inf] <- 20
  
# plot
p_common_up <- ggplot(df_top) +
  geom_point(
    aes(
      x = ratio,
      y = Pathway,
      color = logP,
      size = Count
    )
  ) +
  scale_colour_gradient2(
    low = "blue",
    mid = "purple",
    high = "red",
    midpoint = (range(df_top$logP)[1] + range(df_top$logP)[2]) / 2) +
  theme_bw() +
  labs(
    title = "Hallmark Gene Sets",
    x = "Ratio",
    y = "Gene Set",
    size = "Count",
    color = "-log10(adj. p-value)"
  )

ggsave(
  filename = file.path(
    gseaDIR,
    "Common_up_regulated_Hallmarks.pdf"
  ),
  plot = p_common_up,
  device = "pdf",
  dpi = "retina"
)

```

#### **2.4.1.3 Gemeinsamkeiten: Durch beide Medikamente hoch-regulierte Hallmark Gensets**

```{r}
p_common_up
```

![](images/clipboard-3060932773.png)

#### **2.4.1.4 Unterschiede 1: Nur in Sorafenib hoch-regulierte Hallmark Gensets**

```{r}
sora_up_hyp <- hyperG(
  geneSets = hallmark,
  DEgenes = df_sora_up$Symbol,
  
  universe = universe,
  cutoff = 1,
  mincount = 2,
  parallel = F,
  set.size = c(10,500)
)
```

```{r}

df <- sora_up_hyp
df$ratio <- df$Size / length(universe)
df_top <- df[1:25,]
df_top$Pathway <- gsub(pattern = "HALLMARK_", replacement = "", x = df_top$Term)
df_top <- df_top[order(df_top$ratio, decreasing = F), ]
df_top$Pathway <- factor(df_top$Pathway, levels = df_top$Pathway)
df_top$logP <- -log10(df_top$adj.P.Val)
df_top$logP[df_top$logP == Inf] <- 20
  
# plot
sora_up_plot <- ggplot(df_top) +
  geom_point(
    aes(
      x = ratio,
      y = Pathway,
      color = logP,
      size = Count
    )
  ) +
  scale_colour_gradient2(
    low = "blue",
    mid = "purple",
    high = "red",
    midpoint = (range(df_top$logP)[1] + range(df_top$logP)[2]) / 2) +
  theme_bw() +
  labs(
    title = "Hallmark Gene Sets Sora up ",
    x = "Ratio",
    y = "Gene Set",
    size = "Count",
    color = "-log10(adj. p-value)"
  )

ggsave(
  filename = file.path(
    gseaDIR,
    "only_up_regulated_Sorafenib_Hallmarks.pdf"
  ),
  plot = sora_up_plot,
  device = "pdf",
  dpi = "retina"
)
```

```{r}
sora_up_plot
```

![](images/clipboard-989977573.png)

#### **2.4.1.5 Unterschiede 2: Nur in Trametinib hoch-regulierte Hallmark Gensets**

```{r}
tram_up_hyp <- hyperG(
  geneSets = hallmark,
  DEgenes = df_tram_up$Symbol,
  universe = universe,
  cutoff = 0.0001,
  mincount = 2,
  parallel = F,
  set.size = c(10,500)
)
```

```{r}

df <- tram_up_hyp
df$ratio <- df$Size / length(universe)
df_top <- df
df_top$Pathway <- gsub(pattern = "HALLMARK_", replacement = "", x = df_top$Term)
df_top <- df_top[order(df_top$ratio, decreasing = F), ]
df_top$Pathway <- factor(df_top$Pathway, levels = df_top$Pathway)
df_top$logP <- -log10(df_top$adj.P.Val)
df_top$logP[df_top$logP == Inf] <- 20
  
# plot
tram_up_plot <- ggplot(df_top) +
  geom_point(
    aes(
      x = ratio,
      y = Pathway,
      color = logP,
      size = Count
    )
  ) +
  scale_colour_gradient2(
    low = "blue",
    mid = "purple",
    high = "red",
    midpoint = (range(df_top$logP)[1] + range(df_top$logP)[2]) / 2) +
  theme_bw() +
  labs(
    title = "Hallmark Gene Sets Tram Up",
    x = "Ratio",
    y = "Gene Set",
    size = "Count",
    color = "-log10(adj. p-value)"
  )

ggsave(
  filename = file.path(
    gseaDIR,
    "only_up_regulated_Trametinib_Hallmarks.pdf"
  ),
  plot = tram_up_plot,
  device = "pdf",
  dpi = "retina"
)
```

```{r}
tram_up_plot
```

Für Tram keine hochregulierten Pathways gefunden

#### **2.4.1.6 Gemeinsamkeiten: Durch beide Medikamente runter-regulierte Hallmark Gensets**

```{r}
common_down_hyp <- hyperG(
  geneSets = hallmark,
  DEgenes = df_set_down_both$Symbol,
  universe = universe,
  cutoff = 0.1,
  mincount = 2,
  parallel = F,
  set.size = c(10,500)
)

```

```{r}
df <- common_down_hyp
df$ratio <- df$Size / length(universe)
df_top <- df[1:25,]
df_top$Pathway <- gsub(pattern = "HALLMARK_", replacement = "", x = df_top$Term)
df_top <- df_top[order(df_top$ratio, decreasing = F), ]
df_top$Pathway <- factor(df_top$Pathway, levels = df_top$Pathway)
df_top$logP <- -log10(df_top$adj.P.Val)
df_top$logP[df_top$logP == Inf] <- 20
  
# plot
#p_common_down <- ggplot(df_top) +
common_down_plot <- ggplot(df_top) +
  geom_point(
    aes(
      x = ratio,
      y = Pathway,
      color = logP,
      size = Count
    )
  ) +
  scale_colour_gradient2(
    low = "blue",
    mid = "purple",
    high = "red",
    midpoint = (range(df_top$logP)[1] + range(df_top$logP)[2]) / 2) +
  theme_bw() +
  labs(
    title = "Hallmark Gene Sets",
    x = "Ratio",
    y = "Gene Set",
    size = "Count",
    color = "-log10(adj. p-value)"
  ) #+theme(axis.text.x = element_text(angle = 90))

ggsave(
  filename = file.path(
    gseaDIR,
    "Common_down_regulated_Hallmarks.pdf"
  ),
  plot = common_down_plot,
  device = "pdf",
  dpi = "retina"
)
```

```{r}
common_down_plot
```

![](images/clipboard-157060531.png)

#### **2.4.1.7 Unterschiede 1: Nur in Sorafenib runter-regulierte Hallmark Gensets**

```{r}
sora_down_hyp <- hyperG(
  geneSets = hallmark,
  DEgenes = df_sora_down$Symbol,
  universe = universe,
  cutoff = 0.1,
  mincount = 2,
  parallel = F,
  set.size = c(10,500)
)
```

```{r}

df <- sora_down_hyp
df$ratio <- df$Size / length(universe)
df_top <- df[1:25,]
df_top$Pathway <- gsub(pattern = "HALLMARK_", replacement = "", x = df_top$Term)
df_top <- df_top[order(df_top$ratio, decreasing = F), ]
df_top$Pathway <- factor(df_top$Pathway, levels = df_top$Pathway)
df_top$logP <- -log10(df_top$adj.P.Val)
df_top$logP[df_top$logP == Inf] <- 20
  
# plot
sora_down_plot <- ggplot(df_top) +
  geom_point(
    aes(
      x = ratio,
      y = Pathway,
      color = logP,
      size = Count
    )
  ) +
  scale_colour_gradient2(
    low = "blue",
    mid = "purple",
    high = "red",
    midpoint = (range(df_top$logP)[1] + range(df_top$logP)[2]) / 2) +
  theme_bw() +
  labs(
    title = "Hallmark Gene Sets Sora Down",
    x = "Ratio",
    y = "Gene Set",
    size = "Count",
    color = "-log10(adj. p-value)"
  )

ggsave(
  filename = file.path(
    gseaDIR,
    "only_down_regulated_Sorefenib_Hallmarks.pdf"
  ),
  plot = sora_down_plot,
  device = "pdf",
  dpi = "retina"
)
```

```{r}
sora_down_plot
```

![](images/clipboard-1171102807.png)

#### **2.4.1.8 Unterschiede 2: Nur in Trametinib runter-regulierte Hallmark Gensets**

```{r}
tram_down_hyp <- hyperG(
  geneSets = hallmark,
 # DEgenes = df_tram_down$Symbol,
  DEgenes = resLFC_tram_dmso.final.down$Symbol,
  universe = universe,
  cutoff = 0.1,
  mincount = 2,
  parallel = F,
  set.size = c(10,500)
)
```

```{r}
df <- tram_down_hyp
df$ratio <- df$Size / length(universe)
df_top <- df
df_top$Pathway <- gsub(pattern = "HALLMARK_", replacement = "", x = df_top$Term)
df_top <- df_top[order(df_top$ratio, decreasing = F), ]
df_top$Pathway <- factor(df_top$Pathway, levels = df_top$Pathway)
df_top$logP <- -log10(df_top$adj.P.Val)
df_top$logP[df_top$logP == Inf] <- 20
  
# plot
tram_down_plot_1 <- ggplot(df_top) +
  geom_point(
    aes(
      x = ratio,
      y = Pathway,
      color = logP,
      size = Count
    )
  ) +
  scale_colour_gradient2(
    low = "blue",
    mid = "purple",
    high = "red",
    midpoint = (range(df_top$logP)[1] + range(df_top$logP)[2]) / 2) +
  theme_bw() +
  labs(
    title = "Hallmark Gene Sets Tram down",
    x = "Ratio",
    y = "Gene Set",
    size = "Count",
    color = "-log10(adj. p-value)"
  )

ggsave(
  filename = file.path(
    gseaDIR,
    "only_down_regulated_Trametinib_Hallmarks.pdf"
  ),
  plot = tram_down_plot_1,
  device = "pdf",
  dpi = "retina"
)
```

```{r}
tram_down_plot_1
```

![](images/clipboard-1477509847.png)

[Bedeutung der Gene, in der Aufgabenstellung genannt werden:]{.underline}

***BRAF^D594G^***,:

BRAF ist ein Proto-Onkogen, das ein Serin/Threonin-Kinase-Protein codiert.Es ist Teil der MAPK/ERK-Signalkaskade, die Zellteilung, Differenzierung und Überleben steuert.Mutationen im BRAF-Gen können zu einer dauerhaften Aktivierung einer Signalkette führen, die zu unkontrolliertem Zellwachstum und damit zu Krebs führt. Die Aminosäuremutation D594G bedeutet, dass die Aminosäure Aspartat (D) an Position 594 durch Glycin (G) ersetzt wird

***KRAS^G12A^***

Eine KRAS-Mutation ist eine Veränderung im KRAS-Gen, die bei vielen Krebsarten eine Rolle spielt, insbesondere bei Lungen-, Darm- und Bauchspeicheldrüsenkrebs. KRAS ist ein Protein, das an der Signalübertragung beteiligt ist und das Zellwachstum reguliert. Mutationen können dazu führen, dass das Protein dauerhaft aktiviert ist und unkontrolliertes Zellwachstum fördert. Die Bezeichnung G12A bedeutet, dass an Position 12 der Aminosäuresequenz die Glycin (G)-Aminosäure durch Alanin (A) ersetzt wurde – das ist eine Punktmutation. Diese ist jedoch aktuell schwer direkt behandelbar („undruggable“), obwohl an Therapien geforscht wird.

***TP53^R175H^*** ist eine spezifische Mutation (Punktmutation) im TP53-Gen, die auch als p53-R175H bekannt ist. Diese Mutation tritt häufig in verschiedenen Krebsarten auf und wird als "Hotspot-Mutation" bezeichnet, da sie in der DNA-Bindungsdomäne des p53-Proteins liegt

[Medikamente]{.underline}

**Sorafenib** stoppt die vermehrte [Zellteilung](https://flexikon.doccheck.com/de/Zellteilung) und unterbindet die Blutversorgung des [Tumors](https://flexikon.doccheck.com/de/Tumor). Die Substanz soll über einen dualen Wirkmechanismus verfügen:

-   Sorafenib unterbricht den Signalweg, der die Tumorzelle zu fortgesetzter Teilung anregt. Genauer Angriffspunkt ist die [RAF-Kinase](https://flexikon.doccheck.com/index.php?title=RAF-Kinase&action=edit&redlink=1 "RAF-Kinase (Artikel jetzt erstellen...)"), die von Sorafenib gehemmt wird. Diese Kinase aktiviert eine Kaskade von Enzymen, die letztendlich im [Zellkern](https://flexikon.doccheck.com/de/Zellkern) die Zellteilung auslöst.

-   Sorafenib hemmt die [Angioneogenese](https://flexikon.doccheck.com/de/Angioneogenese) des Tumors, indem die [intrazelluläre](https://flexikon.doccheck.com/de/Intrazellul%C3%A4r) [Tyrosinkinasedomäne](https://flexikon.doccheck.com/de/Tyrosinkinase) des [VEGF-Rezeptors](https://flexikon.doccheck.com/de/VEGF-Rezeptor) blockiert wird. Neu gebildete Tumorzellen werden nicht mehr an das Gefäßsystem angeschlossen, und daher nicht mit Nährstoffen versorgt.

**Trametinib** ist ein [Arzneistoff](https://de.wikipedia.org/wiki/Arzneistoff "Arzneistoff") aus der Gruppe der Kinaseinhibitoren. Es wird allein oder in Kombination mit dem Arzneistoff [Dabrafenib](https://de.wikipedia.org/wiki/Dabrafenib "Dabrafenib") zur Behandlung einer bestimmten Hautkrebsart ([Melanom](https://de.wikipedia.org/wiki/Melanom "Melanom")) verwendet, die sich in andere Körperregionen ausgebreitet hat oder nicht durch eine Operation entfernt werden kann, und welche eine bestimmte Veränderung ([Mutation](https://de.wikipedia.org/wiki/Mutatio "Mutatio")) an der Position V600 des sogenannten [B-Raf](https://de.wikipedia.org/wiki/Raf_(Protein) "Raf (Protein)")-Gens aufweist. Ebenfalls in Kombination mit Dabrafenib wird Trametinib zur Behandlung des fortgeschrittenen [nicht-kleinzelligen Lungenkarzinoms](https://de.wikipedia.org/wiki/Bronchialkarzinom#Pathologie_der_Subtypen "Bronchialkarzinom") (NSCLC) mit B-Raf-V600-Mutation eingesetzt

[Welche Gene werden von Trametinib hochreguliert ?]{.underline}

Obwohl Trametinib hauptsächlich Gene herunterreguliert, die mit Zellproliferation und Überleben assoziiert sind, gibt es spezifische Gene wie ISG15 und PD-L1, deren Expression unter seiner Wirkung erhöht sein kann. Diese Veränderungen könnten potenziell therapeutische Implikationen haben, insbesondere in Kombination mit Immuntherapien

[Welche Gene werden von Trametinib runterreguliert ?]{.underline}

Trametinib führt typischerweise zur Herunterregulation von Genen, die durch den MAPK/ERK-Weg aktiviert werden und für Zellproliferation, Überleben und Migration wichtig sind. Dazu gehören Cyclin D1, MYC, EGR1, FOS, JUN und weitere mit Zellzyklus und Tumorprogression assoziierte Gene.

( deckt sich mit dem, was wir mit der Analyse gefunden haben)

Begrenzung der Arbeit: Vielleicht sollte man mehr als zwei Replikate nehmen

```{r}
sessionInfo()
```
